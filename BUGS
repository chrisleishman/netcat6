Known bugs that have not been resolved yet:

-----------------------------------------------------------------------------

Sending data to a UDP host that isn't listening gives a strange error:

$ ./nc6 -u -4 localhost 9876
hi
nc6: error reading from fd 3: Connection refused

This isn't intuitive at all and should be fixed.
-----------------------------------------------------------------------------

On some linux systems (and perhaps others), a nc6 listening on all local
addresses, but using IPv6 only (with the -6 option) will still accept
connections from clients using IPv4.  This is because these systems don't have
a separate stack for IPv6 and IPv4 - instead simply treating all IPv4 as being
encapsulated within IPv6 - and don't have a way to instruct the kernel to only
accept true IPv6 connections.

<client>
$ ./nc6 -4 -v localhost 9876
nc6: localhost (127.0.0.1) 9876 [9876] open

<server>
$ ./nc6 -6 -v -l -p 9876
nc6: listening on :: 8765 ...
nc6: connect to ::ffff:127.0.0.1 8765 from localhost (::ffff:127.0.0.1) 37654
[37654]
-----------------------------------------------------------------------------

On the same linux systems (and perhaps others), a nc6 listening on both IPv6
and IPv4 will report IPv4 client connections using IPv4 mapped IPv6 addresses,
rather than just IPv4.

<client>
$ ./nc6 -4 -v localhost 9876
nc6: localhost (127.0.0.1) 9876 [9876] open

<server>
$ ./nc6 -v -l -p 9876
nc6: listening on :: 8765 ...
nc6: listening on 0.0.0.0 8765 ...
nc6: connect to ::ffff:127.0.0.1 8765 from localhost (::ffff:127.0.0.1) 37654
[37654]
-----------------------------------------------------------------------------

In default mode, if an EOF is received from the remote server (resulting in an
'instant' hold timeout) and there is still data waiting to be sent, then a
write will be attempted - potentially resulting in a EPIPE result (because the
server has really gone away).  This will in turn cause nc6 to exit with a
failed status code, contrary to the specified behavior.

To resolve this, after a hold timeout occurs on an endpoint, all errors from
attempting to write to the endpoint should be ignored (but NOT errors from
trying to write to the other one), or perhaps we should simply stop trying to
send any data to the endpoint that timed out (since the delivery of this data
isn't guaranteed anyway - but note that the delivery of the data FROM the
endpoint that timed out still has to occur since it is guaranteed).
-----------------------------------------------------------------------------
